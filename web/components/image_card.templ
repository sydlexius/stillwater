package components

import (
	"fmt"
	"strconv"

	"github.com/sydlexius/stillwater/internal/provider"
)

// sourceBadgeColor returns a Tailwind color class for the provider source badge.
func sourceBadgeColor(source string) string {
	switch source {
	case "fanarttv":
		return "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200"
	case "audiodb":
		return "bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200"
	case "discogs":
		return "bg-orange-100 dark:bg-orange-900 text-orange-800 dark:text-orange-200"
	case "musicbrainz":
		return "bg-amber-100 dark:bg-amber-900 text-amber-800 dark:text-amber-200"
	case "duckduckgo":
		return "bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200"
	default:
		return "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200"
	}
}

// isLowResolution returns true if the image dimensions indicate low quality for the given type.
// imageType is normalized via normalizeCardImageType so provider-specific aliases
// (hdlogo, background, widethumb) map to their base types before comparison.
func isLowResolution(w, h int, imageType string) bool {
	if w == 0 || h == 0 {
		return false
	}
	switch normalizeCardImageType(imageType) {
	case "banner":
		return w < 758 || h < 140
	case "fanart":
		return w < 960 || h < 540
	case "logo":
		return w < 400 || h < 155
	default: // thumb, poster, folder, widethumb
		return w < 500 || h < 500
	}
}

// normalizeCardImageType maps provider-specific types to base types for crop/compare.
func normalizeCardImageType(t string) string {
	switch t {
	case "hdlogo":
		return "logo"
	case "widethumb":
		return "thumb"
	case "background":
		return "fanart"
	default:
		return t
	}
}

templ ImageCard(artistID string, img provider.ImageResult) {
	<div
		class={ "relative rounded-lg border border-gray-200 dark:border-gray-700 overflow-hidden group hover:border-blue-400 dark:hover:border-blue-500 transition-colors", }
		data-img-url={ img.URL }
		data-img-type={ normalizeCardImageType(string(img.Type)) }
		data-img-source={ img.Source }
		data-img-width={ strconv.Itoa(img.Width) }
		data-img-height={ strconv.Itoa(img.Height) }
	>
		<div
			class={
				"aspect-square flex items-center justify-center overflow-hidden",
				templ.KV("checkered-bg", string(img.Type) == "logo" || string(img.Type) == "hdlogo"),
				templ.KV("bg-gray-100 dark:bg-gray-900", string(img.Type) != "logo" && string(img.Type) != "hdlogo"),
			}
		>
			<img
				src={ img.URL }
				alt={ string(img.Type) + " from " + img.Source }
				class="max-w-full max-h-full object-contain"
				loading="lazy"
				onerror="this.style.display='none';this.nextElementSibling.style.display='flex';"
			/>
			<div class="hidden items-center justify-center flex-col gap-1 text-gray-400 dark:text-gray-500 p-4" style="display:none;">
				<svg class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909M3.75 21h16.5A2.25 2.25 0 0 0 22.5 18.75V5.25A2.25 2.25 0 0 0 20.25 3H3.75A2.25 2.25 0 0 0 1.5 5.25v13.5A2.25 2.25 0 0 0 3.75 21Z"></path>
				</svg>
				<span class="text-xs">Image unavailable</span>
			</div>
		</div>
		<div class="p-2 space-y-1">
			<div class="flex items-center gap-1 flex-wrap">
				<span class={ "inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium", sourceBadgeColor(img.Source) }>
					{ provider.ProviderName(img.Source).DisplayName() }
				</span>
				<span class="inline-flex items-center rounded-full bg-gray-100 dark:bg-gray-700 px-2 py-0.5 text-xs text-gray-600 dark:text-gray-400">
					{ string(img.Type) }
				</span>
			</div>
			<div class="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400">
				if img.Width > 0 && img.Height > 0 {
					<span>{ strconv.Itoa(img.Width) }x{ strconv.Itoa(img.Height) }</span>
				} else {
					<span class="italic">Unknown size</span>
				}
				if img.Likes > 0 {
					<span>{ strconv.Itoa(img.Likes) } likes</span>
				}
			</div>
			if isLowResolution(img.Width, img.Height, normalizeCardImageType(string(img.Type))) {
				<div class="text-xs text-amber-600 dark:text-amber-400">Low resolution</div>
			}
			if (string(img.Type) == "logo" || string(img.Type) == "hdlogo") && img.Source == "duckduckgo" {
				<div class="text-xs text-amber-600 dark:text-amber-400">Check transparency before saving</div>
			}
			<button
				type="button"
				class="w-full mt-1 text-sm px-2 py-2 rounded bg-blue-600 text-white hover:bg-blue-700 transition-colors"
				hx-post={ fmt.Sprintf("/api/v1/artists/%s/images/fetch", artistID) }
				hx-vals={ fmt.Sprintf(`{"url":"%s","type":"%s"}`, img.URL, string(img.Type)) }
				hx-swap="none"
				hx-confirm="Save this image?"
				data-confirm-key="image-save"
			>
				Save
			</button>
			<div class="flex gap-1">
				<button
					type="button"
					class="compare-btn hidden flex-1 text-sm px-2 py-1 rounded border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
					onclick="if(typeof populateCompare==='function') populateCompare(this.closest('[data-img-url]'))"
				>
					Compare
				</button>
				<button
					type="button"
					class="crop-btn hidden flex-1 text-sm px-2 py-1 rounded border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
					onclick="if(typeof openCropModal==='function') openCropModal(this.closest('[data-img-url]').dataset.imgUrl, this.closest('[data-img-url]').dataset.imgType)"
				>
					Crop
				</button>
			</div>
		</div>
	</div>
}
